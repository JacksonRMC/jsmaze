<?xml-stylesheet href="#maze-style" type="text/css"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

	<head>
		<title>Maze</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<style type="text/css" id="maze-style">
			html { width: 100%; height: 100%; }
			body, div, table, tr, th, td { margin: 0; padding: 0; border: 0; }
			body { width: 100%; height: 100%; background: #ddd; }
			div#wrap { width: 90%; height: 90%; margin: auto auto; }
			div#svg-container { width: 100%; height: 90%; background: #fff; }
			h1 { float: left; }
			div#form { float: right; width: 70%; min-height: 30px; position: relative; top: 20px; }
		</style>
		<script type="text/javascript">
			// <![CDATA[

			// Get query parameters from the url.  This returns an object like this:
			//	?param            => args['param']=true
			// ?param=value      => args['param']=value
			// ?param[]=value    => args['param']=[value,...]
			function get_args() {
				var args = new Object();

				var query_string=location.search.slice(1);
				if (!query_string) return args;
				var query_pairs = query_string.split('&');

				var pname, pvalue;

				for (var i=0 ; i<query_pairs.length ; i++) {
					var equal_position=query_pairs[i].indexOf('=');
					if (equal_position<0) {
						args[my_uri_decoder(query_pairs[i])]=true;
					} else {
						pname=my_uri_decoder(query_pairs[i].slice(0,equal_position));
						pvalue=my_uri_decoder(query_pairs[i].slice(equal_position+1));
						// If a name is followed by [], then we'll create an array of
						// values.  This is good for a multiple-select box
						if (pname.indexOf('[]')==pname.length-2) {
							pname=pname.slice(0,-2);
							if (!args[pname]) args[pname]=new Array();
							args[pname].push(pvalue);
						} else {
							args[pname]=pvalue;
						}
					}
				}

				return args;
			}

			function my_uri_decoder(v) {
				return decodeURIComponent(v.replace(/\+/g,'%20'));
			}

			// Easily add functions to run at load time
			function add_body_onload(func) {
				var old_body_onload=window.onload;
				window.onload=function() {
					if (old_body_onload) { old_body_onload(); }
					func();
				}
			}

			// Gives us a random permutation.  This is Durstenfeld's
			// version of Knuth's shuffle, with in-place swapping.
			function random_perm(len) {
				var orig=Array(len);
				for (var x=0; x<len; x++) {
					orig[x]=x;
				}
				for (var x=len-1; x>0; x--) {
					var offset=Math.floor(Math.random()*(x+1));
					if (offset != x) {
						var tmp = orig[offset];
						orig[offset] = orig[x];
						orig[x] = tmp;
					}
				}
				return orig;
			}

			// The maze is set on a set of points, some of which connect to
			// form walls.  A closed set of walls connects to create a
			// cell.  We use object references between cells and walls
			// to quickly be able to traverse the maze.  So, a wall has a
			// list of both cells to which it connects and a cell has a
			// list of all of its walls.
			//
			// Points have an x,y coordinate that exists to specify their
			// position relative to other points.  They also have a set of
			// walls that use them as an end point.

			function Point(x, y) {
				this.x=x;
				this.y=y;
				this.walls=[];
			}

			Point.prototype.angle_to = function(other_point) {
				return Math.atan2(other_point.y-this.y,other_point.x-this.x)
			}

			Point.prototype.next_cw_wall = function(this_wall) {
				var wall_at = null;
				for (var j=0 ; j<this.walls.length ; j++) {
					if (this.walls[j] == this_wall) {
						wall_at = j;
						break;
					}
				}
				if (wall_at !== null) {
					if (wall_at > 0) {
						return this.walls[wall_at-1];
					} else {
						return this.walls[this.walls.length-1];
					}
				} else {
					return null;
				}
			}

			// Walls have a few pieces of information: two end points, the
			// state (open (0) or closed (1)), and the two cells that it
			// connects.

			function Wall(p1,p2) {
				this.points=[p1,p2];
				this.state=1;
				this.cells=[];
				p1.walls.push(this);
				p2.walls.push(this);
				// These are used for face finding - "down" is "point 0 to
				// point 1", "up" is "point 1 to point 0".
				this.traversed_down=false;
				this.traversed_up=false;
			}

			Wall.prototype.is_open = function() {
				return (this.state==0);
			}

			Wall.prototype.open = function() {
				if (this.state==0) {
					return null;
				} else {
					this.state=0;
					return true;
				}
			}

			Wall.prototype.center = function() {
				return(new Point((this.points[0].x+this.points[1].x)/2,(this.points[0].y+this.points[1].y)/2));
			}

			// Given a point, returns the "other end" point on the wall.
			Wall.prototype.other_end = function(point) {
				if (this.points[0] == point) {
					return(this.points[1]);
				} else if (this.points[1] == point) {
					return(this.points[0]);
				} else {
					return null;
				}
			}

			Wall.prototype.traverse = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					this.traversed_down = true;
					return point1;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					this.traversed_up = true;
					return point1;
				} else {
					return null;
				}
			}

			Wall.prototype.traversed = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					return this.traversed_down;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					return this.traversed_up;
				} else {
					return null;
				}
			}

			Wall.prototype.toString = function() {
				return "" + this.points[0].x + ',' + this.points[0].y + ':' + this.points[1].x + ',' + this.points[1].y;
			}

			// Each wall has one or two cells (it's possible that
			// an edge wall may have only one cell).  This will
			// return "undefined" if there is no neighbor, otherwise it
			// will return the neighbor given a reference to one cell.
			Wall.prototype.neighbor = function(cell) {
				if (this.cells[0] == cell) {
					return this.cells[1];
				} else {
					return this.cells[0];
				}
			}

			// Helper to get the length of a wall
			Wall.prototype.length = function() {
				return Math.sqrt(Math.pow(this.points[0].x-this.points[1].x,2) + Math.pow(this.points[0].y-this.points[1].y,2));
			}

			// Cells have a set of walls along with a few other pieces of
			// information that are used while generating a maze.
			// Generally, a permutation of wall directions and a pointer to
			// the "current" item in the permutation list.

			function Cell(walls) {
				this.walls = walls;
				for (var i=0 ; i<this.walls.length ; i++) {
					this.walls[i].cells.push(this);
				}
				this.perm=random_perm(this.walls.length);
				this.current_perm=0;
				this.entry_wall=undefined;
				this.depth=undefined;
				// Used in drunk walk algorithm
				this.serial=undefined;
			}

			// Returns true if the cell has an open wall
			Cell.prototype.visited = function() {
				for (var i=0 ; i<this.walls.length ; i++) {
					if (this.walls[i].is_open()) {
						return true;
					}
				}
				return false;
			}

			// Returns a point representing the exact center of the cell.
			Cell.prototype.center = function() {
				var x_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					x_avg += this.walls[i].points[0].x;
					x_avg += this.walls[i].points[1].x;
				}
				x_avg /= this.walls.length * 2;
				var y_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					y_avg += this.walls[i].points[0].y;
					y_avg += this.walls[i].points[1].y;
				}
				y_avg /= this.walls.length * 2;
				return(new Point(x_avg,y_avg));
			}

			// Return a list of all vertices of a cell, in order
			Cell.prototype.vertices = function() {
				var points = [];
				// I need to pick only a single point from each wall, and it
				// will be the point that isn't in the next wall.
				for (var i=0 ; i<this.walls.length ; i++) {
					var this_wall = this.walls[i];
					var next_wall = this.walls[i+1];
					if (!next_wall) { next_wall = this.walls[0]; }
					if (this_wall.points[0] != next_wall.points[0] && this_wall.points[0] != next_wall.points[1]) {
						points.push(this_wall.points[0]);
					} else {
						points.push(this_wall.points[1]);
					}
				}
				return points;
			}

			// A maze is a collection of cells with a path through them.
			// It is two graphs that are interconnected - one which is a
			// set of all walls (close and open) and the other a path
			// through the open walls.  This data structure holds
			// everything of interest about the maze.
			function Maze(xsize,ysize,base_style,maze_style) {
				// General data and accessors
				this.points = [];
				this.walls = [];
				this.cells = [];
				this.start_point=null;
				this.end_point=null;
				this.start_wall=null;
				this.end_wall=null;
				this.max_depth=null;
				this.end_depth=null;

				this.base_style=Maze.base_styles_info[base_style];
				if (!this.base_style) {
					throw new Error("Unknown base style: " + base_style);
				}
				this.maze_style=Maze.maze_styles_info[maze_style];
				if (!this.maze_style) {
					throw new Error("Unknown maze style: " + maze_style);
				}

				if (xsize < this.maze_style.min_xsize) {
					throw new Error("Minimum xsize is " + this.maze_style.min_xsize);
				}
				if (ysize < this.maze_style.min_ysize) {
					throw new Error("Minimum ysize is " + this.maze_style.min_ysize);
				}

				this.xsize = xsize * this.base_style.x_multiplier;
				this.ysize = ysize * this.base_style.y_multiplier;

				// Now, we'll initialize the maze.  First, set up the cells
				// according to the "base style".
				this.base_style.algo.call(this, this.xsize, this.ysize, this.points, this.walls);
				this.sort_walls_for_points(this.points);
				// We now have a complete set of points and walls, we need to
				// walk that data structure and determine a set of cells.
				// In graph parlance, points == vertices, walls == edges, and
				// cells == faces.
				// There's a better more efficient way to do this - figure it
				// out later.
				// TODO: figure out a more efficient way to do this
				for (var j=0 ; j<this.points.length ; j++) {
					this.find_faces(this.points[j], this.cells);
				}
				// At this point, we're ready to actually make a maze.  Get
				// the start and end cells, then generate the maze.
				this.start_wall = this.find_start_wall(this.points);
				this.end_wall = this.find_end_wall(this.points);
				this.maze_style.algo.call(this);
				// Purely for aesthetics, open the corners
				this.open_corners();
				// And set the max depth and end depth, which are useful for
				// rendering.
				this.find_max_depth();
				this.end_depth = this.end_cell().depth;
			}

			Maze.base_styles = {};
			Maze.maze_styles = {};

			// To create a maze, we need to move around until we're back to
			// the original point.  There's enough information stored in
			// each cell to perform this algorithm non-recursively in a
			// while loop.
			// If performed recursively, this algorithm is simple...
			Maze.maze_styles.recursive = function() {
				function recursive_maze(cell,entry_wall,depth) {
					cell.depth=depth;
					cell.entry_wall=entry_wall;
					// Now, go through the surrounding cells and recurse
					for (var k=0 ; k<cell.perm.length ; k++) {
						var wall_num = cell.perm[k];
						var neighbor = cell.walls[wall_num].neighbor(cell);
						if (neighbor && !neighbor.visited()) {
							cell.walls[wall_num].open();
							arguments.callee(neighbor,cell.walls[wall_num],depth+1);
						}
					}
				}

				recursive_maze(this.start_cell(),null,0);
			}

			// Create a maze using the drunk walk algorithm.  In this
			// algorithm, we create random segments that grow like the
			// recursive algorithm above until they connect to another
			// existing segment.  Each cell has a "serial" number that
			// specifies which segment it belongs to, so as a segment grows
			// it can see if it's touching "self" or "other".  It will
			// connect to "other" and quit growing.
			Maze.maze_styles.drunk_walk = function() {
				function drunk_walk(cell, entry_wall, serial, depth) {
					pieces_left--;
					cell.serial = serial;
					if (depth==0) return false;
					for (var k=0 ; k<cell.perm.length ; k++) {
						var wall_num = cell.perm[k];
						var wall = cell.walls[wall_num];
						if (wall != entry_wall && !wall.is_open()) {
							var neighbor = wall.neighbor(cell);
							if (neighbor) {
								if (!neighbor.serial) {
									wall.open();
									var ret=arguments.callee(neighbor,wall,serial,depth-1);
									if (!ret) return false;
								} else if (neighbor.serial != serial) {
									wall.open();
									return false;
								}
							}
						}
					}
					return true;
				}

				// Note that this is a scoped variable - the "drunk_walk"
				// function refers to it.
				var pieces_left = this.cells.length;

				// Note that this is declared here but the drunk_walk
				// function has "serial" as an argument, also.
				var serial = 1;

				// Grow an initial segment starting at a random location.
				// The length of the segment is up to 1/10th of the
				// available cells + 5.
				drunk_walk(this.cells[Math.floor(Math.random()*pieces_left)], null, serial++, Math.floor(Math.random()*pieces_left/10)+5);

				// Now, keep growing segments until we run out of pieces
				while (pieces_left>0) {
					var next_start=Math.floor(Math.random()*pieces_left)+1;
					var empty_found=0, i;
					for (i=0 ; i<this.cells.length ; i++) {
						if (!this.cells[i].serial) {
							empty_found++;
							if (empty_found >= next_start) {
								drunk_walk(this.cells[i], null, serial++, 99999999);
								break;
							}
						}
					}
				}

				this.find_depth(this.start_cell(), null, 0);
			}

			// Recursively finds the depths of all cells given a starting
			// point.  Make sure to do this before opening the start and
			// end.  This will also point all "entry walls" to the
			// beginning.
			Maze.prototype.find_depth = function(cell,entry_wall,depth) {
				cell.depth = depth;
				cell.entry_wall = entry_wall;
				for (var k=0 ; k<cell.walls.length; k++) {
					if (cell.walls[k] != entry_wall && cell.walls[k].is_open()) {
						arguments.callee(cell.walls[k].neighbor(cell),cell.walls[k],depth+1);
					}
				}
			}

			Maze.prototype.find_max_depth = function() {
				this.max_depth=0;
				for (var i=0 ; i<this.cells.length ; i++) {
					if (this.cells[i].depth > this.max_depth) { this.max_depth = this.cells[i].depth; }
				}
				return this.max_depth;
			}

			Maze.prototype.start_cell = function() {
				return this.start_wall.cells[0];
			}

			Maze.prototype.end_cell = function() {
				return this.end_wall.cells[0];
			}

			// This will create a simple square maze
			Maze.base_styles.square = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				for (var x=0 ; x<= xsize ; x++) {
					points_tracker[x] = Array(ysize+1);
					for (var y=0 ; y<= ysize ; y++) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build vertical walls
						if (y>0) {
							all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x][y]));
						}
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-1][y],points_tracker[x][y]));
						}
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][0];
				this.end_point = points_tracker[xsize][ysize];
			}

			// Triangle maze - on odd rows the points are in odd columns,
			// in even rows the points are in even columns.
			Maze.base_styles.triangle = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				// First, make the points - even lines/cols
				for (var x = 0 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 0 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Next, make the points - odd lines/cols
				for (var x = 1 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 1 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>1) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Now, make walls from even cols to odd cols
				for (var x = 0 ; x < xsize ; x += 2) {
					for (var y=0 ; y < ysize ; y += 2) {
						if (points_tracker[x+1]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x][y+2]));
							}
						}
						if (points_tracker[x+2]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x+2][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x+2][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x+2][y+2]));
							}
						}
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][0];
				for (var x=xsize ; x>0 ; x--) {
					this.end_point = points_tracker[x][ysize];
					if (this.end_point) { break; }
				}
			}

			// Hexagonal maze
			Maze.base_styles.hexagonal = function(xsize,ysize,all_points,all_walls) {
				// Might have to adjust xsize - it should be 4+6*(k-1) wide,
				// where k is the original xsize
				this.xsize = 4 + 6 * (xsize - 1);
				this.ysize = 2 * ysize;

				xsize = this.xsize;
				ysize = this.ysize;

				// points_tracker[y][x] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(ysize+1);

				// First, make the points - even lines
				for (var y = 0 ; y < ysize+1 ; y += 2) {
					points_tracker[y] = Array(xsize+1);
					for (var x = 1 ; x < xsize+1 ; x += 6) {
						points_tracker[y][x] = new Point(x,y);
						all_points.push(points_tracker[y][x]);
						points_tracker[y][x+2] = new Point(x+2,y);
						all_points.push(points_tracker[y][x]);
						// Build horizontal walls
						all_walls.push(new Wall(points_tracker[y][x],points_tracker[y][x+2]));
					}
				}

				// Next, make the points - odd lines
				for (var y = 1 ; y < ysize+1 ; y += 2) {
					points_tracker[y] = Array(ysize+1);
					// First, put a lone point at 0,0
					points_tracker[y][0] = new Point(0,y);
					all_points.push(points_tracker[y][0]);
					// And another lone point at the end of the line
					points_tracker[y][xsize] = new Point(xsize,y);
					all_points.push(points_tracker[y][xsize]);
					for (var x = 4 ; x < xsize ; x += 6) {
						points_tracker[y][x] = new Point(x,y);
						all_points.push(points_tracker[y][x]);
						points_tracker[y][x+2] = new Point(x+2,y);
						all_points.push(points_tracker[y][x]);
						// Build horizontal walls
						all_walls.push(new Wall(points_tracker[y][x],points_tracker[y][x+2]));
					}
				}

				for (var y = 0 ; y < ysize ; y += 2) {
					for (var x = 1 ; x < xsize ; x += 6) {
						all_walls.push(new Wall(points_tracker[y][x],points_tracker[y+1][x-1]));
						all_walls.push(new Wall(points_tracker[y+1][x-1],points_tracker[y+2][x]));
						all_walls.push(new Wall(points_tracker[y][x+2],points_tracker[y+1][x+3]));
						all_walls.push(new Wall(points_tracker[y+1][x+3],points_tracker[y+2][x+2]));
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][1];
				this.end_point = points_tracker[ysize][xsize-1];
			}

			// Diamond maze
			Maze.base_styles.diamond = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				// First, make the points - even lines/odd cols
				for (var x = 0 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 1 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
					}
				}

				// Next, make the points - odd lines/even cols
				for (var x = 1 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 0 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
					}
				}

				for (var x = 1 ; x < xsize ; x += 2) {
					for (var y = 0 ; y < ysize ; y += 2) {
						all_walls.push(new Wall(points_tracker[x][y],points_tracker[x-1][y+1]));
						all_walls.push(new Wall(points_tracker[x][y],points_tracker[x+1][y+1]));
						all_walls.push(new Wall(points_tracker[x-1][y+1],points_tracker[x][y+2]));
						all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x][y+2]));
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[1][0];
				this.end_point = points_tracker[xsize-1][ysize];
			}

			// This will create a square/triangle maze - each square is
			// made of four triangles.
			Maze.base_styles.squaretriangles = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				for (var x=0 ; x<= xsize ; x+=2) {
					points_tracker[x] = Array(ysize+1);
					if (x>0) {
						points_tracker[x-1] = Array(ysize+1);
					}
					for (var y=0 ; y<= ysize ; y+=2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build vertical walls
						if (y>0) {
							all_walls.push(new Wall(points_tracker[x][y-2], points_tracker[x][y]));
						}
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
							// Build diagonal walls
							if (y>0) {
								points_tracker[x-1][y-1] = new Point(x-1,y-1);
								all_points.push(points_tracker[x-1][y-1]);
								all_walls.push(new Wall(points_tracker[x-1][y-1],points_tracker[x-2][y-2]));
								all_walls.push(new Wall(points_tracker[x-1][y-1],points_tracker[x-2][y]));
								all_walls.push(new Wall(points_tracker[x-1][y-1],points_tracker[x][y-2]));
								all_walls.push(new Wall(points_tracker[x-1][y-1],points_tracker[x][y]));
							}
						}
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][0];
				this.end_point = points_tracker[xsize][ysize];
			}

			// This will create a snub square tiling, with squares at each
			// corner.  I totally cheat, of course.  What I make is a
			// set of perfect squares with every other square being cut
			// into two right triangles, the direction depending on whether
			// the row is odd or even.  I can then rotate the squares ever
			// so slightly just right to make the triangles equilateral.
			// Basically, we can think of the straight squares (starting in
			// corners and then every other square) as being rotated CCW by
			// 15 degrees.  This can be simplified to a set of x,y offsets
			// depending on the location of the point, basically whether x
			// and y are odd or even.  Furthermore, since it's a perfect
			// square the offsets need only be computed one time and
			// applied properly to each corner.
			Maze.base_styles.snubsquare = function(xsize,ysize,all_points,all_walls) {
				// Need to make sure xsize and ysize are odd
				this.xsize = this.xsize | 1;
				this.ysize = this.ysize | 1;

				xsize = this.xsize;
				ysize = this.ysize;

				// Offsets
				var upper_right_x_offset = Math.cos(60.0*Math.PI/180.0) - Math.cos(45.0*Math.PI/180.0);
				var upper_right_y_offset = Math.sin(60.0*Math.PI/180.0) - Math.sin(45.0*Math.PI/180.0);
				upper_right_x_offset /= Math.sqrt(2);
				upper_right_y_offset /= Math.sqrt(2);

				// offsets[x][y] where "x" and "y" are 0 or 1
				var offsets = [
					[
					  { x: -upper_right_x_offset, y: -upper_right_y_offset }, // 0,0
					  { x: -upper_right_y_offset, y: upper_right_x_offset }, // 0,1
					],
					[
					  { x: upper_right_y_offset, y: -upper_right_x_offset }, // 1,0
					  { x: upper_right_x_offset, y: upper_right_y_offset }, // 1,1
					]
				];

				// Each square has to be moved toward the origin by twice this
				// value for each square.  It's easy to work the math out.
				// My method is a little ghetto, but I don't care.  It works
				// and it's easy to understand.
				var scale_offset = 1.0 - Math.cos(15.0*Math.PI/180.0);

				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				for (var x=0 ; x<= xsize ; x++) {
					points_tracker[x] = Array(ysize+1);
					for (var y=0 ; y<= ysize ; y++) {
						points_tracker[x][y] = new Point(
							x - (2*Math.floor(x/2.0)*scale_offset) + offsets[x&1][y&1].x,
							y - (2*Math.floor(y/2.0)*scale_offset) + offsets[x&1][y&1].y);
						all_points.push(points_tracker[x][y]);
						// Build vertical walls
						if (y>0) {
							all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x][y]));
						}
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-1][y],points_tracker[x][y]));
						}
						// Now, build diagonal walls where proper.  On even columns
						// and odd rows, build a diagonal down to the left
						if (x>0 && !(x&1) && y&1) {
							all_walls.push(new Wall(points_tracker[x][y],points_tracker[x-1][y-1]));
						}
						// On odd columns and even rows, build a diagonal up
						// to the left
						if (x&1 && !(y&1) && y>0) {
							all_walls.push(new Wall(points_tracker[x][y-1],points_tracker[x-1][y]));
						}
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][0];
				this.end_point = points_tracker[xsize][ysize];

				// Reset xsize and ysize to reflect actual size of maze
				this.xsize = points_tracker[xsize][ysize].x;
				this.ysize = points_tracker[xsize][ysize].y;
			}

			// Snub square tiling set at 45 degrees from the other way of doing it.
			Maze.base_styles.snubsquare2 = function(xsize,ysize,all_points,all_walls) {
				// Ensure that xsize and ysize are even - go up to next number
				// if odd.
				xsize = ((xsize + 1) | 1) - 1
				ysize = ((ysize + 1) | 1) - 1

				this.xsize = xsize;
				this.ysize = ysize;

				// Setting the recurring pattern on a 7x7 grid
				xarraysize = xsize * 6 / 2 + 1;
				yarraysize = ysize * 6 / 2 + 1;

				// Offsets
				var offsets = [
					0,
					.5,
					Math.cos(30.0*Math.PI/180.0),
					Math.cos(30.0*Math.PI/180.0) + .5,
					Math.cos(30.0*Math.PI/180.0) + 1.0,
					2 * Math.cos(30.0*Math.PI/180.0) + .5,
					2 * Math.cos(30.0*Math.PI/180.0) + 1
				];

				var every_2_offset = offsets[6];

				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xarraysize+1);

				for (var x=0 ; x<= xsize*3 ; x+=6) {
					for (var j=0 ; j<6 ; j++) {
						points_tracker[x+j] = Array(yarraysize+1);
					}
					for (var y=0 ; y<= ysize*3 ; y+=6) {
						if (y>0) {
							points_tracker[x][y-5] = new Point(x,y-5);
							all_points.push(points_tracker[x][y-5]);
							points_tracker[x][y-1] = new Point(x,y-1);
							all_points.push(points_tracker[x][y-1]);
							if (y>6) {
								all_walls.push(new Wall(points_tracker[x][y-5], points_tracker[x][y-7]));
							}
						}
						if (x>0) {
							points_tracker[x-4][y] = new Point(x-4,y);
							all_points.push(points_tracker[x-4][y]);
							points_tracker[x-2][y] = new Point(x-2,y);
							all_points.push(points_tracker[x-2][y]);
							all_walls.push(new Wall(points_tracker[x-4][y], points_tracker[x-2][y]));
							if (y>0) {
								points_tracker[x-3][y-2] = new Point(x-3,y-2);
								all_points.push(points_tracker[x-3][y-2]);
								points_tracker[x-3][y-4] = new Point(x-3,y-4);
								all_points.push(points_tracker[x-3][y-4]);
								points_tracker[x-1][y-3] = new Point(x-1,y-3);
								all_points.push(points_tracker[x-1][y-3]);
								points_tracker[x-5][y-3] = new Point(x-5,y-3);
								all_points.push(points_tracker[x-5][y-3]);
								// build the walls
								all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x-2][y]));
								all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x-1][y-3]));
								all_walls.push(new Wall(points_tracker[x][y-5], points_tracker[x-1][y-3]));
								all_walls.push(new Wall(points_tracker[x][y-5], points_tracker[x-2][y-6]));

								all_walls.push(new Wall(points_tracker[x-6][y-1], points_tracker[x-4][y]));
								all_walls.push(new Wall(points_tracker[x-6][y-1], points_tracker[x-5][y-3]));
								all_walls.push(new Wall(points_tracker[x-6][y-5], points_tracker[x-5][y-3]));
								all_walls.push(new Wall(points_tracker[x-6][y-5], points_tracker[x-4][y-6]));

								all_walls.push(new Wall(points_tracker[x-3][y-2], points_tracker[x-2][y]));
								all_walls.push(new Wall(points_tracker[x-3][y-2], points_tracker[x-1][y-3]));
								all_walls.push(new Wall(points_tracker[x-3][y-2], points_tracker[x-3][y-4]));
								all_walls.push(new Wall(points_tracker[x-3][y-2], points_tracker[x-5][y-3]));
								all_walls.push(new Wall(points_tracker[x-3][y-2], points_tracker[x-4][y]));

								all_walls.push(new Wall(points_tracker[x-3][y-4], points_tracker[x-1][y-3]));
								all_walls.push(new Wall(points_tracker[x-3][y-4], points_tracker[x-2][y-6]));
								all_walls.push(new Wall(points_tracker[x-3][y-4], points_tracker[x-4][y-6]));
								all_walls.push(new Wall(points_tracker[x-3][y-4], points_tracker[x-5][y-3]));

								if (x>6) {
									all_walls.push(new Wall(points_tracker[x-5][y-3], points_tracker[x-7][y-3]));
								}
							}
						}
					}
				}

				// Set offset for all points
				for (var j=0 ; j<all_points.length ; j++) {
					var p = all_points[j];
					var old_x = p.x;
					var old_y = p.y;
					p.x = Math.floor(old_x/6)*every_2_offset + offsets[old_x % 6];
					p.y = Math.floor(old_y/6)*every_2_offset + offsets[old_y % 6];
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][1];
				this.end_point = points_tracker[xsize*3][ysize*3-1];

				// Reset xsize and ysize to reflect actual size of maze
				this.xsize = points_tracker[xsize*3][ysize*3-1].x;
				this.ysize = points_tracker[xsize*3-2][ysize*3].y;
			}

			// Cairo tiling is based on a series of pentagons in groups of
			// four.  Each pentagon has 4 walls of equal length and a
			// single shorter wall.  We can create a snub square tiling
			// pattern first that consists of 5 squares and 8 triangles
			// (although we technically need only 2 squares and 3
			// triangles).  The centers of each square and triangle then
			// become the vertices of the pentagons in a single repeated
			// pattern.  The pattern is rotationally symmetric around the
			// center of the center square, so we can compute only one
			// single pentagon and rotate it through to get the rest of the
			// coordinates.
			//
			// But the pattern can actually be computed in a simpler
			// manner.  Each pentagon has two 90 degree angles.  The center
			// square is rotated 15 degrees CW, and the opposite 90 degree
			// angles are rotated 15 degrees CCW.  The angle where the two
			// equilateral sides meet is then 120 degrees.  Thus, the other
			// angles are also 120 degrees.
			//
			// Going back to the snub square method, we can easily see that
			// the "long" walls are made of two segments - one is half the
			// length of the square's walls (which are a single unit) and
			// the other is the distance from the perpendicular in the
			// middle of an equilateral triangle's side (also a single
			// unit) to the center.  The "short" walls are then twice the
			// distance from the center of the triangle.
			//
			// Working out the math, the length of the long wall is
			// .5 + .5 x tan(30)
			// and the length of the short wall is
			// 2 x .5 x tan(30)    - which is just tan(30)
			//
			// So we can think of each group of 4 in a pattern where the
			// center has 4 long lines connecting at 90 degree angles.  The
			// other end of each line is a point which connects to a long
			// line on the CW side at a 120 degree angle and to a short
			// line on the CCW side at a 120 degree angle.  Continuing CW
			// we have another long line, this time at a 90 degree angle,
			// and then we're to the short line at a 120 degree angle
			// (at which point we've completed the shape).  Now, we need to
			// take that entire structure and rotate it 15 degrees CW.  We
			// can tile a plane with this shape.
			//
			// So, we'll compute the as a center point and 3 "offsets"
			// from there.

			Maze.base_styles.cairo = function(xsize,ysize,all_points,all_walls) {
				// Need to make sure xsize and ysize are even
				this.xsize = (this.xsize & 1 ? this.xsize + 1 : this.xsize);
				this.ysize = (this.ysize & 1 ? this.ysize + 1 : this.ysize);

				// There are 3 x positions for every 2 cells
				xsize = this.xsize * 1.5;
				ysize = this.ysize;

				var long_line_length = 0.5 + Math.tan(30.0*Math.PI/180.0) / 2.0;
				var short_line_length = Math.tan(30.0*Math.PI/180.0);
				// Offsets - assuming "center" is 0,0 - we compute three
				// other points.
				var p1 = new Point(
					Math.sin(15.0*Math.PI/180.0) * long_line_length,
					Math.cos(15.0*Math.PI/180.0) * long_line_length
				);
				// Same offsets - just x and y reversed
				var p2 = new Point(
					p1.x + p1.y,
					p1.y + p1.x
				);
				// Same offset values as first time, but y is subtracted
				var p3 = new Point(
					p2.x + p1.x,
					p2.y - p1.y
				);
				var center_offset = new Point(
					p3.x, p3.x
				);

				// In order to fit in a structure with a (0,0) origin, we
				// need to offset the entire thing such that the vertex on
				// the CCW side of the short line is "0" - one for "x" and
				// one for "y".  It's the same distance from the center,
				// though - and it's the "x" offset of p3.  In the same way,
				// the width and height of one group of 4 is p1.y + p3.x.
				// Divided by 2, that number is the multiplier from the snub
				// square layout - cos(15).

				// Each square has to be moved toward the origin by twice this
				// value for each square.  It's easy to work the math out.
				// My method is a little ghetto, but I don't care.  It works
				// and it's easy to understand.
				var scale_offset = Math.cos(15.0*Math.PI/180.0);

				// points_tracker[y][x] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(ysize+1);

				for (var y=0 ; y <= ysize ; y+=2) {

					points_tracker[y] = Array(xsize+2);
					if (y>1) {
						points_tracker[y-1] = Array(xsize+2);
					}

					for (var x=0 ; x<= xsize ; x+=3) {

						points_tracker[y][x] = new Point(x,y);
						all_points.push(points_tracker[y][x]);

						if (x>0) {
							// Build 3 walls back along x
							points_tracker[y][x-1] = new Point(x-1,y);
							all_points.push(points_tracker[y][x-1]);
							all_walls.push(new Wall(points_tracker[y][x], points_tracker[y][x-1]));

							points_tracker[y][x-2] = new Point(x-2,y);
							all_points.push(points_tracker[y][x-2]);
							all_walls.push(new Wall(points_tracker[y][x-1], points_tracker[y][x-2]));

							all_walls.push(new Wall(points_tracker[y][x-2], points_tracker[y][x-3]));
						}

						if (y>0) {
							// Build 3 walls back again.
							points_tracker[y-1][x+1] = new Point(x+1,y-1);
							all_points.push(points_tracker[y-1][x+1]);
							all_walls.push(new Wall(points_tracker[y][x], points_tracker[y-1][x+1]));

							points_tracker[y-1][x] = new Point(x,y-1);
							all_points.push(points_tracker[y-1][x]);
							all_walls.push(new Wall(points_tracker[y-1][x+1], points_tracker[y-1][x]));

							all_walls.push(new Wall(points_tracker[y-1][x], points_tracker[y-2][x]));

							if (x>0) {
								// Note that this is the "center"
								points_tracker[y-1][x-1] = new Point(x-1,y-1);
								all_points.push(points_tracker[y-1][x-1]);

								all_walls.push(new Wall(points_tracker[y-1][x-1], points_tracker[y][x-1]));
								all_walls.push(new Wall(points_tracker[y-1][x-1], points_tracker[y-1][x]));
								all_walls.push(new Wall(points_tracker[y-1][x-1], points_tracker[y-1][x-2]));
								all_walls.push(new Wall(points_tracker[y-1][x-1], points_tracker[y-2][x-2]));
							}
						}
					}
				}

				// Set cell offsets
				for (var x=2 ; x < xsize ; x+=3) {
					for (var y=1 ; y < ysize ; y+=2) {
						// The cell at x,y is a "center" cell.  I'll make it "1,1" for purposes of this.
						center = points_tracker[y][x];
						center.x = ((center.x-2)/3*2+1) * scale_offset;
						center.y = center.y * scale_offset;

						var center_x = center.x;
						var center_y = center.y;

						// 4 points connected to center
						points_tracker[y+1][x].x = center_x + p1.x;
						points_tracker[y+1][x].y = center_y + p1.y;

						points_tracker[y][x+1].x = center_x + p1.y;
						points_tracker[y][x+1].y = center_y - p1.x;

						if (y==1) {
							points_tracker[y-1][x-1].x = center_x - p1.x;
							points_tracker[y-1][x-1].y = center_y - p1.y;
						}

						if (x==2) {
							points_tracker[y][x-1].x = center_x - p1.y;
							points_tracker[y][x-1].y = center_y + p1.x;
						}

						// Next 4 points CW
						points_tracker[y+1][x+1].x = center_x + p2.x;
						points_tracker[y+1][x+1].y = center_y + p2.y;

						if (y==1) {
							points_tracker[y-1][x-2].x = center_x - p2.x;
							points_tracker[y-1][x-2].y = center_y - p2.y;

							points_tracker[y-1][x+1].x = center_x + p2.y;
							points_tracker[y-1][x+1].y = center_y - p2.x;
						}

						if (x==2) {
							points_tracker[y+1][x-2].x = center_x - p2.y;
							points_tracker[y+1][x-2].y = center_y + p2.x;
						}

						// Next 4 points CW
						points_tracker[y][x+2].x = center_x + p3.x;
						points_tracker[y][x+2].y = center_y + p3.y;

						if (x==2) {
							points_tracker[y][x-2].x = center_x - p3.x;
							points_tracker[y][x-2].y = center_y - p3.y;
						}

						points_tracker[y+1][x-1].x = center_x - p3.y;
						points_tracker[y+1][x-1].y = center_y + p3.x;

						if (y==1) {
							points_tracker[y-1][x].x = center_x + p3.y;
							points_tracker[y-1][x].y = center_y - p3.x;
						}
					}
				}

				for (x=0 ; x<=xsize ; x++) {
					for (y=0 ; y<=ysize ; y++) {
						if (points_tracker[y] && points_tracker[y][x]) {
							if (points_tracker[y][x].x == x || points_tracker[y][x].y == y) {
								console.log("Unmoved point: " + x + "," + y + " is at " + points_tracker[y][x].x + "," + points_tracker[y][x].y);
							}
						}
					}
				}

				// Last, set the start and end points
				this.start_point = points_tracker[0][0];
				this.end_point = points_tracker[ysize][xsize];

				// Reset xsize and ysize to reflect actual size of maze
				this.xsize = points_tracker[ysize-1][xsize].x;
				this.ysize = points_tracker[ysize][xsize].y;
			}

			// Round maze.
			// So, xsize becomes a ring count and ysize becomes a density
			// measurement.  The first two rings are the center and are one
			// single cell.  The density tells how many cells will be
			// around the first complete ring (the third ring).  That also
			// sets the minimum cell size.
			//
			// As the maze adds rings, the cells will become larger.  When
			// the cells are twice or more the size of the original cells
			// at ring 3 they will split.
			//
			// The cells on each ring will be staggered from the next.
			Maze.base_styles.round = function(ring_count,density,all_points,all_walls) {
				// points_tracker[ring][i] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(ring_count+1);

				this.xsize = ring_count * 2;
				this.ysize = ring_count * 2;

				var inner_radius = 1;

				var radians = Math.PI * 2.0;

				// Determine when to split the cells
				var smallest_outer_length = 2.0 * ((inner_radius + 1) * radians / density);

				for (var ring = inner_radius ; ring <= ring_count ; ring++) {
					points_tracker[ring] = Array(density);
					var this_outer_length = 2.0 * (ring * radians / density);
					var splitting = (this_outer_length > smallest_outer_length * 2.0);
					if (splitting) {
						density *= 2;
					}
					for (var i=0 ; i < density ; i++) {
						var x,y,theta;
						theta = i * radians / density;
						x = ring * Math.cos(theta) + ring_count;
						y = ring * Math.sin(theta) + ring_count;
						points_tracker[ring][i] = new Point(x,y);
						all_points.push(points_tracker[ring][i]);
						// Build ring
						if (i>0) {
							all_walls.push(new Wall(points_tracker[ring][i-1], points_tracker[ring][i]));
						}
						// Build radial walls
						if (ring>inner_radius) {
							// This will stagger the walls.
							if (splitting) {
								if ((i&1) == 0 && ((i/2)&1) == (ring&1)) {
									all_walls.push(new Wall(points_tracker[ring-1][i/2],points_tracker[ring][i]));
								}
							} else {
								if ((i&1) == (ring&1)) {
									all_walls.push(new Wall(points_tracker[ring-1][i],points_tracker[ring][i]));
								}
							}
						}
					}
					// complete the ring
					all_walls.push(new Wall(points_tracker[ring][density-1], points_tracker[ring][0]));
				}

				// Last, set the start and end points
				this.start_point = points_tracker[ring_count][0];
				this.end_point = points_tracker[ring_count][Math.round(density / 2)];
			}

			Maze.base_styles_info = {
				'square': {
					'min_xsize': 2,
					'min_ysize': 2,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 4,
					'algo': Maze.base_styles.square
				},
				'triangle': {
					'min_xsize': 2,
					'min_ysize': 2,
					'x_multiplier': 2,
					'y_multiplier': 1,
					'max_face_size': 3,
					'algo': Maze.base_styles.triangle
				},
				'hexagonal': {
					'min_xsize': 4,
					'min_ysize': 4,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 6,
					'algo': Maze.base_styles.hexagonal
				},
				'diamond': {
					'min_xsize': 4,
					'min_ysize': 4,
					'x_multiplier': 2,
					'y_multiplier': 2,
					'max_face_size': 4,
					'algo': Maze.base_styles.diamond
				},
				'squaretriangles': {
					'min_xsize': 4,
					'min_ysize': 4,
					'x_multiplier': 2,
					'y_multiplier': 2,
					'max_face_size': 4,
					'algo': Maze.base_styles.squaretriangles
				},
				'snubsquare': {
					'min_xsize': 3,
					'min_ysize': 3,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 4,
					'algo': Maze.base_styles.snubsquare
				},
				'snubsquare2': {
					'min_xsize': 2,
					'min_ysize': 2,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 4,
					'algo': Maze.base_styles.snubsquare2
				},
				'cairo': {
					'min_xsize': 2,
					'min_ysize': 2,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 5,
					'algo': Maze.base_styles.cairo
				},
				'round': {
					'min_xsize': 2,
					'min_ysize': 2,
					'x_multiplier': 1,
					'y_multiplier': 1,
					'max_face_size': 20,
					'algo': Maze.base_styles.round
				}
			};

			Maze.maze_styles_info = {
				'recursive': {
					'name': 'recursive',
					'algo': Maze.maze_styles.recursive
				},
				'drunk_walk': {
					'name': 'drunk_walk',
					'algo': Maze.maze_styles.drunk_walk
				}
			};

			// To ease the face-finding algorithm, we can sort the walls at
			// each point in order of angle.
			Maze.prototype.sort_walls_for_points = function(points) {
				for (var i = 0 ; i < points.length ; i++) {
					var point = points[i];
					// array of arrays: [wall, angle]
					var walls = [];
					for (var j = 0 ; j < point.walls.length ; j++) {
						var wall = point.walls[j];
						walls.push([wall,point.angle_to(wall.other_end(point))]);
					}
					function wall_sorter(a,b) { return(a[1]-b[1]); }
					walls.sort(wall_sorter);
					point.walls = [];
					for (var j = 0 ; j < walls.length ; j++) {
						point.walls.push(walls[j][0]);
					}
				}
			}

			// Finds all faces attached to a point that aren't yet "found"
			// and adds them to an array.  The "signed_area" makes sure
			// that we only find faces that have walls/vertices in
			// clockwise order.  The reason is that the algorithm will find
			// the face from all of the outside walls.  The
			// "safety_counter" can also make it fairly easy to ignore
			// those, but ultimately the only real way to ignore it in all
			// circumstances is to recognize that it'll have a negative
			// "signed_area".
			Maze.prototype.find_faces = function(point, all_cells) {
				for (var i=0 ; i<point.walls.length ; i++) {
					var wall = point.walls[i];
					if (!wall.traversed(point,wall.other_end(point))) {
						var safety_counter = 0;
						var this_point=point;
						var walls = [];
						var signed_area = 0;
						var other_point;
						do {
							walls.push(wall);
							other_point = wall.other_end(this_point);
							signed_area += (this_point.x * other_point.y - other_point.x * this_point.y);
							this_point = wall.traverse(this_point,other_point);
							wall = this_point.next_cw_wall(wall)
							safety_counter++;
						} while (this_point != point && safety_counter <= this.base_style.max_face_size);
						if (walls.length <= this.base_style.max_face_size && signed_area > 0) {
							all_cells.push(new Cell(walls));
						}
					}
				}
			}

			// Find the upper left starting wall
			Maze.prototype.find_start_wall = function(points) {
				var start_cell = this.start_point.walls[0].cells[0];
				// First, try to find a horizontal wall
				for (var k=0 ; k<this.start_point.walls.length ; k++) {
					var wall = this.start_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open() && wall.other_end(this.start_point).y == this.start_point.y) {
						return wall;
					}
				}
				// If that doesn't work, find one that is at the upper left
				for (var k=0 ; k<this.start_point.walls.length ; k++) {
					var wall = this.start_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open() && wall.other_end(this.start_point).x <= this.start_point.x) {
						return wall;
					}
				}
				// And if that doesn't work, grab the first one that I can
				for (var k=0 ; k<this.start_point.walls.length ; k++) {
					var wall = this.start_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open()) {
						return wall;
					}
				}
			}

			// Find the lower right ending wall
			Maze.prototype.find_end_wall = function(points) {
				var end_cell = this.end_point.walls[0].cells[0];
				// First, try to find one that's flat on the bottom
				for (var k=0 ; k<this.end_point.walls.length ; k++) {
					var wall = this.end_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open() && wall.other_end(this.end_point).y == this.end_point.y) {
						return wall;
					}
				}
				// If that doesn't work, try to find one that's at the lower right
				for (var k=0 ; k<this.end_point.walls.length ; k++) {
					var wall = this.end_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open() && wall.other_end(this.end_point).x >= this.end_point.x) {
						return wall;
					}
				}
				// And if that doesn't work just grab one
				for (var k=this.end_point.walls.length-1 ; k>=0 ; k--) {
					var wall = this.end_point.walls[k];
					if (wall.cells.length==1 && !wall.is_open()) {
						return wall;
					}
				}
			}

			// Opens the corners - knocks down walls to create a start and
			// end for the maze.
			Maze.prototype.open_corners = function() {
				// open opposite corners
				this.start_wall.open();
				this.end_wall.open();
			}

			//////////////////////////////////////////////////////////////
			//                                                          //
			//       Everything from here down pertains to display      //
			//                                                          //
			//////////////////////////////////////////////////////////////

			// Clear an existing svg element
			function destroy_svg_element(div_id) {
				var container_div = document.getElementById(div_id);
				var svgs = container_div.getElementsByTagName('svg');
				for (var i=0 ; i<svgs.length ; i++) {
					container_div.removeChild(svgs[i]);
				}
			}

			// Creates an svg element inside a container div
			function create_svg_element(div_id) {
				var container_div = document.getElementById(div_id);
				var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				svg.setAttribute("version", "1.2");
				svg.setAttribute("baseProfile", "tiny");
				svg.setAttribute("width", "100%");
				svg.setAttribute("height", "100%");
				var style = document.createElementNS("http://www.w3.org/2000/svg", "style");
				var stylesheet = document.createTextNode("line.wall.open { display: none; }");
				style.appendChild(stylesheet);
				svg.appendChild(style);
				container_div.appendChild(svg);
				return svg;
			}

			// Get the svg
			function find_svg(div_id) {
				var container_div = document.getElementById(div_id);
				return container_div.getElementsByTagName('svg')[0];
			}

			// Find a reference to the svg's stylesheet
			function svg_find_stylesheet(svg) {
				return(svg.getElementsByTagName('style')[0]);
			}

			// Get the svg's width.  The issue here is that on Firefox the
			// svg's offsetWidth is undefined, so I need to instead get the
			// parent's offsetWidth.
			function svg_width(svg) {
				return svg.offsetWidth || svg.parentNode.offsetWidth;
			}

			// Get the height of the svg.
			function svg_height(svg) {
				return svg.offsetHeight || svg.parentNode.offsetHeight;
			}

			// Given the number of cells and svg, compute a width for
			// a single cell.
			function xmult_for(xsize, svg) {
				return svg_width(svg) / (xsize + 2);
			}

			// Given the number of cells and svg, compute a height for
			// a single cell.
			function ymult_for(ysize, svg) {
				return svg_height(svg) / (ysize + 2);
			}

			// Draw the background for the maze
			function draw_gradient_bg(end_depth, max_depth, svg) {
				var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
				defs.setAttribute('id', 'svgdefs');
				svg.appendChild(defs);

				var lg = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
				lg.setAttribute('id', 'svgbg');
				lg.setAttribute('x1', '0%');
				lg.setAttribute('x2', '100%');
				lg.setAttribute('y1', '0%');
				lg.setAttribute('y2', '100%');
				defs.appendChild(lg);

				var stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
				stop1.setAttribute('id', 'stop1');
				stop1.setAttribute('offset', '0%');
				stop1.setAttribute('stop-color', 'rgb(0,0,255)');
				lg.appendChild(stop1);

				var stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
				stop2.setAttribute('id', 'stop2');
				stop2.setAttribute('offset', '100%');
				stop2.setAttribute('stop-color', 'rgb(0,0,' + (255-Math.floor((end_depth/max_depth)*255)) + ')');
				lg.appendChild(stop2);

				var r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
				r.setAttribute("x", 0);
				r.setAttribute("y", 0);
				r.setAttribute("width", svg_width(svg));
				r.setAttribute("height", svg_height(svg));
				r.setAttribute("fill", 'url(#svgbg)');
				r.setAttribute("stroke", 'rgb(0,0,255)');
				r.setAttribute("stroke-width", "1");
				r.setAttribute("id", "bg");
				svg.appendChild(r);
			}

			// Draws the cells shaded according to depth, with
			// light blue being "shallow" and black being "deep"
			function draw_cell_depths(cells, xsize, ysize, max_depth, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x < cells.length ; x++) {
					var cell = cells[x];
					var points = cell.vertices();
					var points_list = [];
					for (var i=0 ; i < points.length ; i++) {
						points_list.push("" + Math.floor(points[i].x * xmult + xmult) + "," + Math.floor(points[i].y * ymult + ymult));
					}
					var p = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
					p.setAttribute("points", points_list.join(" "));
					p.setAttribute("fill", 'rgb(0,0,' + (255-Math.floor((cell.depth/max_depth)*255)) + ')');
					p.setAttribute("stroke", 'rgb(0,0,' + (255-Math.floor((cell.depth/max_depth)*255)) + ')');
					p.setAttribute("stroke-width", "1");
					p.setAttribute("class", "depth-map");
					svg.appendChild(p);
				}
			}

			// Draws a set of walls on an svg
			function draw_walls(walls, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x < walls.length ; x++) {
					var wall = walls[x];
					var l = document.createElementNS("http://www.w3.org/2000/svg", "line");
					l.setAttribute("x1", wall.points[0].x * xmult + xmult);
					l.setAttribute("y1", wall.points[0].y * ymult + ymult);
					l.setAttribute("x2", wall.points[1].x * xmult + xmult);
					l.setAttribute("y2", wall.points[1].y * ymult + ymult);
					if (wall.is_open()) {
						l.setAttribute("stroke", "#ff0008");
						l.setAttribute("stroke-width", "1");
						l.setAttribute("class", "open wall");
					} else {
						l.setAttribute("stroke", "#ff0008");
						l.setAttribute("stroke-width", "1");
						l.setAttribute("class", "closed wall");
					}
					svg.appendChild(l);
				}
			}

			// Just draw a "point"
			function draw_point(x, y, color, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
				c.setAttribute("cx", x * xmult + xmult);
				c.setAttribute("cy", y * ymult + ymult);
				c.setAttribute("r", 2);
				c.setAttribute("stroke", color);
				c.setAttribute("stroke-width", "1");
				c.setAttribute("class", "point");
				svg.appendChild(c);
			}

			// This code is useful for debugging the face-finding
			// algorithm.  It puts a red dot in the middle of every
			// face.
			function show_cell_centers(cells, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x< cells.length ; x++) {
					var cell = cells[x];
					var center = cell.center();
					var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
					c.setAttribute("cx", center.x * xmult + xmult);
					c.setAttribute("cy", center.y * ymult + ymult);
					c.setAttribute("r", 2);
					c.setAttribute("stroke", "#ff0008");
					c.setAttribute("stroke-width", "1");
					c.setAttribute("class", "cell-center");
					svg.appendChild(c);
				}
			}

			// This code is useful for debugging - it shows a red dot over
			// the start and end points.
			function show_start_and_end_points(maze, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
				c.setAttribute("cx", maze.end_point.x * xmult + xmult);
				c.setAttribute("cy", maze.end_point.y * ymult + ymult);
				c.setAttribute("r", 2);
				c.setAttribute("stroke", "#ff0008");
				c.setAttribute("stroke-width", "1");
				c.setAttribute("class", "end-point");
				svg.appendChild(c);
				var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
				c.setAttribute("cx", maze.start_point.x * xmult + xmult);
				c.setAttribute("cy", maze.start_point.y * ymult + ymult);
				c.setAttribute("r", 2);
				c.setAttribute("stroke", "#ff0008");
				c.setAttribute("stroke-width", "1");
				c.setAttribute("class", "start-point");
				svg.appendChild(c);
			}

			// Draw the solution to the maze, starting at the end wall and
			// tracing back to the starting wall.
			function show_maze_solution(maze, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);

				var points = [];

				// First, draw from the center of the end wall to the center
				// of the end cell.
				var end_wall_center = maze.end_wall.center();
				var end_cell = maze.end_cell();

				points.push(end_wall_center);

				var start_wall_center = maze.start_wall.center();
				var start_cell = maze.start_cell();

				var current_cell = end_cell;

				do {
					points.push(current_cell.center());
					current_cell = current_cell.entry_wall.neighbor(current_cell);
				} while (current_cell != start_cell)

				points.push(start_cell.center());
				points.push(start_wall_center);

				var points_xy = [];
				for (var i=0 ; i<points.length ; i++) {
					points_xy.push('' + (points[i].x * xmult + xmult) + ',' + (points[i].y * ymult + ymult));
				}

				var points_str = points_xy.join(' ');

				var pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
				pl.setAttribute("points", points_str);
				pl.setAttribute("fill", "none");
				pl.setAttribute("stroke", "#ffff00");
				pl.setAttribute("stroke-width", "1");
				if (!show_solution) {
					pl.setAttribute("style", "display: none;");
				}
				pl.setAttribute("id", "solution");
				svg.appendChild(pl);
			}

			// Selectors for various maze parts:
			//
			// #bg - The background gradiant
			// .depth-map - The individual faces in the depth map
			// .wall - All wall segments
			// .open - Open (invisible) wall segments
			// .closed - Closed (visible) wall segments
			// #solution - The path that shows the maze solution
			// .cell-center - Dots that mark the center of each cell
			// #end-point, #start-point - Dots that mark the official start
			//         and end points
			// 
			// Leaving these as globals
			var args=get_args();

			var xsize=parseInt(args['xsize']);
			var ysize=parseInt(args['ysize']);
			var maze_style = args['style'];
			var maze_algorithm = args['algo'];
			var show_solution = args['solution'];
			if (!xsize) xsize=10;
			if (!ysize) ysize=10;
			if (!maze_style) maze_style='square';
			if (!maze_algorithm) maze_algorithm='recursive';

			// Actually makes the maze
			function make_a_maze() {
				var maze = new Maze(xsize, ysize, maze_style, maze_algorithm);

				// With the maze created, we'll display it
				destroy_svg_element("svg-container");
				var svg = create_svg_element("svg-container");
				draw_gradient_bg(maze.end_depth, maze.max_depth, svg);
				draw_cell_depths(maze.cells, maze.xsize, maze.ysize, maze.max_depth, svg);
				draw_walls(maze.walls, maze.xsize, maze.ysize, svg);
				show_maze_solution(maze, maze.xsize, maze.ysize, svg);
				//show_cell_centers(maze.cells, maze.xsize, maze.ysize, svg);
				//show_start_and_end_points(maze, maze.xsize, maze.ysize, svg);
			}

			function set_up_form() {
				var maze_style_selector = document.getElementById('maze-style-selector');
				for (var key in Maze.base_styles_info) {
					var opt = document.createElement('option');
					opt.setAttribute('value',key);
					opt.appendChild(document.createTextNode(key));
					maze_style_selector.appendChild(opt);
				}

				var maze_algorithm_selector = document.getElementById('maze-algorithm-selector');
				for (var key in Maze.maze_styles_info) {
					var opt = document.createElement('option');
					opt.setAttribute('value',key);
					opt.appendChild(document.createTextNode(key));
					maze_algorithm_selector.appendChild(opt);
				}

				// Now set the defaults
				var x_size_input = document.getElementById('x-size-input');
				var y_size_input = document.getElementById('y-size-input');
				var show_solution_input = document.getElementById('show-solution-input');
				x_size_input.value = xsize;
				y_size_input.value = ysize;
				show_solution_input.checked = show_solution;
				maze_style_selector.value = maze_style;
				maze_algorithm_selector.value = maze_algorithm;
			}

			function new_maze() {
				var maze_style_selector = document.getElementById('maze-style-selector');
				var maze_algorithm_selector = document.getElementById('maze-algorithm-selector');
				var x_size_input = document.getElementById('x-size-input');
				var y_size_input = document.getElementById('y-size-input');
				var show_solution_input = document.getElementById('show-solution-input');
				xsize = parseInt(x_size_input.value);
				ysize = parseInt(y_size_input.value);
				maze_style = maze_style_selector.value;
				maze_algorithm = maze_algorithm_selector.value;
				show_solution = show_solution_input.checked;

				make_a_maze();
			}

			function toggle_solution() {
				var show_solution_input = document.getElementById('show-solution-input');
				show_solution = show_solution_input.checked;
				var solution = document.getElementById('solution');
				if (show_solution) {
					solution.setAttribute("style", "");
				} else {
					solution.setAttribute("style", "display: none;");
				}
			}

			add_body_onload(set_up_form);
			add_body_onload(make_a_maze);

			//]]>
		</script>
	</head>

	<body>

		<div id="wrap">

			<h1>JavaScript Maze</h1>

			<div id="form">
				<select id="maze-style-selector"></select>
				<select id="maze-algorithm-selector"></select>
				<input type="number" id="x-size-input" size="4" maxlength="4" step="1" style="width: 5em;" />
				<input type="number" id="y-size-input" size="4" maxlength="4" step="1" style="width: 5em;" />
				<input type="button" value="Go" id="go-button" onclick="new_maze();" />
				|

				<input type="checkbox" id="show-solution-input" value="1" onclick="toggle_solution();" />
				Show Solution
			</div>

			<br clear="left" />

			<div id="svg-container"></div>

			<script type="text/javascript">
				// <![CDATA[
				//]]>
			</script>

		</div>
	</body>

</html>
