<?xml-stylesheet href="#maze-style" type="text/css"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

	<head>
		<title>Maze</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<style type="text/css" id="maze-style">
			body, div, table, tr, th, td { margin: 0; padding: 0; border: 0; }
			body { background: #ddd; }
			div#wrap { width: 90%; height: 90%; margin: auto auto; }
			div#svg-container { width: 100%; height: 90%; background: #fff; }
		</style>
		<script type="text/javascript">
			// <![CDATA[

			// Get query parameters from the url.  This returns an object like this:
			//	?param            => args['param']=true
			// ?param=value      => args['param']=value
			// ?param[]=value    => args['param']=[value,...]
			function get_args() {
				var args = new Object();

				var query_string=location.search.slice(1);
				if (!query_string) return args;
				var query_pairs = query_string.split('&');

				var pname, pvalue;

				for (var i=0 ; i<query_pairs.length ; i++) {
					var equal_position=query_pairs[i].indexOf('=');
					if (equal_position<0) {
						args[my_uri_decoder(query_pairs[i])]=true;
					} else {
						pname=my_uri_decoder(query_pairs[i].slice(0,equal_position));
						pvalue=my_uri_decoder(query_pairs[i].slice(equal_position+1));
						// If a name is followed by [], then we'll create an array of
						// values.  This is good for a multiple-select box
						if (pname.indexOf('[]')==pname.length-2) {
							pname=pname.slice(0,-2);
							if (!args[pname]) args[pname]=new Array();
							args[pname].push(pvalue);
						} else {
							args[pname]=pvalue;
						}
					}
				}

				return args;
			}

			function my_uri_decoder(v) {
				return decodeURIComponent(v.replace(/\+/g,'%20'));
			}

			// Gives us a random permutation.  This is Durstenfeld's
			// version of Knuth's shuffle, with in-place swapping.
			function random_perm(len) {
				var orig=Array(len);
				for (var x=0; x<len; x++) {
					orig[x]=x;
				}
				for (var x=len-1; x>0; x--) {
					var offset=Math.floor(Math.random()*(x+1));
					if (offset != x) {
						var tmp = orig[offset];
						orig[offset] = orig[x];
						orig[x] = tmp;
					}
				}
				return orig;
			}

			// The maze is set on a set of points, some of which connect to
			// form walls.  A closed set of walls connects to create a
			// cell.  We use object references between cells and walls
			// to quickly be able to traverse the maze.  So, a wall has a
			// list of both cells to which it connects and a cell has a
			// list of all of its walls.
			//
			// Points have an x,y coordinate that exists to specify their
			// position relative to other points.  They also have a set of
			// walls that use them as an end point.

			function Point(x, y) {
				this.x=x;
				this.y=y;
				this.walls=[];
			}

			Point.prototype.angle_to = function(other_point) {
				return Math.atan2(other_point.y-this.y,other_point.x-this.x)
			}

			Point.prototype.next_cw_wall = function(this_wall) {
				var wall_at = null;
				for (var j=0 ; j<this.walls.length ; j++) {
					if (this.walls[j] == this_wall) {
						wall_at = j;
						break;
					}
				}
				if (wall_at !== null) {
					if (wall_at > 0) {
						return this.walls[wall_at-1];
					} else {
						return this.walls[this.walls.length-1];
					}
				} else {
					return null;
				}
			}

			// Walls have a few pieces of information: two end points, the
			// state (open (0) or closed (1)), and the two cells that it
			// connects.

			function Wall(p1,p2) {
				this.points=[p1,p2];
				this.state=1;
				this.cells=[];
				p1.walls.push(this);
				p2.walls.push(this);
				// These are used for face finding - "down" is "point 0 to
				// point 1", "up" is "point 1 to point 0".
				this.traversed_down=false;
				this.traversed_up=false;
			}

			Wall.prototype.is_open = function() {
				return (this.state==0);
			}

			Wall.prototype.open = function() {
				if (this.state==0) {
					return null;
				} else {
					this.state=0;
					return true;
				}
			}

			// Given a point, returns the "other end" point on the wall.
			Wall.prototype.other_end = function(point) {
				if (this.points[0] == point) {
					return(this.points[1]);
				} else if (this.points[1] == point) {
					return(this.points[0]);
				} else {
					return null;
				}
			}

			Wall.prototype.traverse = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					this.traversed_down = true;
					return point1;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					this.traversed_up = true;
					return point1;
				} else {
					return null;
				}
			}

			Wall.prototype.traversed = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					return this.traversed_down;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					return this.traversed_up;
				} else {
					return null;
				}
			}

			Wall.prototype.toString = function() {
				return "" + this.points[0].x + ',' + this.points[0].y + ':' + this.points[1].x + ',' + this.points[1].y;
			}

			// Each wall has one or two cells (it's possible that
			// an edge wall may have only one cell).  This will
			// return "undefined" if there is no neighbor, otherwise it
			// will return the neighbor given a reference to one cell.
			Wall.prototype.neighbor = function(cell) {
				if (this.cells[0] == cell) {
					return this.cells[1];
				} else {
					return this.cells[0];
				}
			}

			// Cells have a set of walls along with a few other pieces of
			// information that are used while generating a maze.
			// Generally, a permutation of wall directions and a pointer to
			// the "current" item in the permutation list.

			function Cell(walls) {
				this.walls = walls;
				for (var i=0 ; i<this.walls.length ; i++) {
					this.walls[i].cells.push(this);
				}
				this.perm=random_perm(this.walls.length);
				this.current_perm=0;
				this.entry=undefined;
				this.depth=undefined;
			}

			// Returns true if the cell has an open wall
			Cell.prototype.visited = function() {
				for (var i=0 ; i<this.walls.length ; i++) {
					if (this.walls[i].is_open()) {
						return true;
					}
				}
				return false;
			}

			// Returns a point representing the exact center of the cell.
			Cell.prototype.center = function() {
				var x_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					x_avg += this.walls[i].points[0].x;
					x_avg += this.walls[i].points[1].x;
				}
				x_avg /= this.walls.length * 2;
				var y_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					y_avg += this.walls[i].points[0].y;
					y_avg += this.walls[i].points[1].y;
				}
				y_avg /= this.walls.length * 2;
				return(new Point(x_avg,y_avg));
			}

			// Return a list of all vertices of a cell, in order
			Cell.prototype.vertices = function() {
				var points = [];
				// I need to pick only a single point from each wall, and it
				// will be the point that isn't in the next wall.
				for (var i=0 ; i<this.walls.length ; i++) {
					var this_wall = this.walls[i];
					var next_wall = this.walls[i+1];
					if (!next_wall) { next_wall = this.walls[0]; }
					if (this_wall.points[0] != next_wall.points[0] && this_wall.points[0] != next_wall.points[1]) {
						points.push(this_wall.points[0]);
					} else {
						points.push(this_wall.points[1]);
					}
				}
				return points;
			}

			// To create a maze, we need to move around until we're back to
			// the original point.

			var maxdepth=0;

			// If performed recursively, this algorithm is simple...
			function make_maze(cell,entry_wall,depth) {

				// update max depth
				if (depth>maxdepth) maxdepth=depth;

				cell.depth=depth;

				// Now, go through the surrounding cells and recurse
				for (var k=0 ; k<cell.perm.length ; k++) {
					var wall_num = cell.perm[k];
					var neighbor = cell.walls[wall_num].neighbor(cell);
					if (neighbor && !neighbor.visited()) {
						cell.walls[wall_num].open();
						make_maze(neighbor,cell.walls[wall_num],depth+1);
					}
				}
			}

			var args=get_args();

			var xsize=parseInt(args['xsize'])+1;
			var ysize=parseInt(args['ysize'])+1;
			if (!xsize) xsize=10;
			if (!ysize) ysize=10;

			// An array with every single point
			var all_points = [];

			// An array with every single wall
			var all_walls = [];

			// This will create a simple square maze
			function make_square_maze_base(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				for (var x=0 ; x<= xsize ; x++) {
					points_tracker[x] = Array(ysize+1);
					for (var y=0 ; y<= ysize ; y++) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build vertical walls
						if (y>0) {
							all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x][y]));
						}
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-1][y],points_tracker[x][y]));
						}
					}
				}
			}

			// Triangle maze - on odd rows the points are in odd columns,
			// in even rows the points are in even columns.
			function make_triangle_maze_base(xsize,ysize,points_tracker,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				// First, make the points - even lines/cols
				for (var x = 0 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 0 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Next, make the points - odd lines/cols
				for (var x = 1 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 1 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>1) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Now, make walls from even cols to odd cols
				for (var x = 0 ; x < xsize ; x += 2) {
					for (var y=0 ; y < ysize ; y += 2) {
						if (points_tracker[x+1]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x][y+2]));
							}
						}
						if (points_tracker[x+2]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x+2][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x+2][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x+2][y+2]));
							}
						}
					}
				}
			}

			make_triangle_maze_base(xsize,ysize,all_points,all_walls);
			//make_square_maze_base(xsize,ysize,all_points,all_walls);

			// To ease the face-finding algorithm, we can sort the walls at
			// each point in order of angle.
			for (var i = 0 ; i < all_points.length ; i++) {
				var point = all_points[i];
				// array of arrays: [wall, angle]
				var walls = [];
				for (var j = 0 ; j < point.walls.length ; j++) {
					var wall = point.walls[j];
					walls.push([wall,point.angle_to(wall.other_end(point))]);
				}
				function wall_sorter(a,b) { return(a[1]-b[1]); }
				walls.sort(wall_sorter);
				point.walls = [];
				for (var j = 0 ; j < walls.length ; j++) {
					point.walls.push(walls[j][0]);
				}
			}

			// We now have a complete set of points and walls, we need to
			// walk that data structure and determine a set of cells.
			// In graph parlance, points == vertices, walls == edges, and
			// cells == faces.

			// An array to keep track of all cells
			var all_cells = [];

			function walk_walls(point, all_cells) {
				for (var i=0 ; i<point.walls.length ; i++) {
					var wall = point.walls[i];
					if (!wall.traversed(point,wall.other_end(point))) {
						var safety_counter = 0;
						var this_point=point;
						var walls = [];
						do {
							walls.push(wall);
							this_point = wall.traverse(this_point,wall.other_end(this_point));
							wall = this_point.next_cw_wall(wall)
							safety_counter++;
						} while (this_point != point && safety_counter < 20);
						if (safety_counter < 20) {
							all_cells.push(new Cell(walls));
						}
					}
				}
			}

			// There's a better more efficient way to do this - figure it
			// out later.
			// TODO: figure out a more efficient way to do this
			for (var j=0 ; j<all_points.length ; j++) {
				walk_walls(all_points[j], all_cells);
			}

			// Now that we have all this, make a maze through the cells
			make_maze(all_cells[0],null,0);

			// Finally, open up the opposite corners for aesthetics
			var found_one=0;
			for (var j=0 ; j<all_points.length ; j++) {
				var point = all_points[j];
				if (point.x==0 && point.y==0) {
					for (var i=0 ; i<point.walls.length ; i++) {
						if (!point.walls[i].is_open()) {
							point.walls[i].open();
							found_one++;
							break;
						}
					}
				} else if (point.x==xsize && point.y==ysize) {
					for (var i=point.walls.length-1 ; i>=0 ; i--) {
						if (!point.walls[i].is_open()) {
							point.walls[i].open();
							found_one++;
							break;
						}
					}
				}
				if (found_one>1) { break; }
			}

			//]]>
		</script>
	</head>

	<body>

		<div id="wrap">

			<h1>JavaScript Maze</h1>

			<div id="svg-container"></div>

			<script type="text/javascript">
				// <![CDATA[
					var container_div = document.getElementById("svg-container");
					var mySvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
					mySvg.setAttribute("version", "1.2");
					mySvg.setAttribute("baseProfile", "tiny");
					container_div.appendChild(mySvg);

					var container_xsize = container_div.offsetWidth;
					var xmult = container_xsize / (xsize + 2);
					var container_ysize = container_div.offsetHeight;
					var ymult = container_ysize / (ysize + 2);

					var r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
					r.setAttribute("x", 0);
					r.setAttribute("y", 0);
					r.setAttribute("width", container_xsize);
					r.setAttribute("height", container_ysize);
					r.setAttribute("fill", 'rgb(0,0,255)');
					r.setAttribute("stroke", 'rgb(0,0,255)');
					r.setAttribute("stroke-width", "1");
					mySvg.appendChild(r);

					// First, draw the depth
					for (var x=0 ; x < all_cells.length ; x++) {
						var cell = all_cells[x];
						var points = cell.vertices();
						var points_list = [];
						for (var i=0 ; i < points.length ; i++) {
							points_list.push("" + Math.floor(points[i].x * xmult + xmult) + "," + Math.floor(points[i].y * ymult + ymult));
						}
						var p = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
						p.setAttribute("points", points_list.join(" "));
						p.setAttribute("fill", 'rgb(0,0,' + (255-Math.floor((cell.depth/maxdepth)*255)) + ')');
						p.setAttribute("stroke", 'rgb(0,0,' + (255-Math.floor((cell.depth/maxdepth)*255)) + ')');
						p.setAttribute("stroke-width", "1");
						mySvg.appendChild(p);
					}

					// Now, draw walls.
					for (var x=0 ; x < all_walls.length ; x++) {
						var wall = all_walls[x];
						if (!wall.is_open()) {
							var l = document.createElementNS("http://www.w3.org/2000/svg", "line");
							l.setAttribute("x1", wall.points[0].x * xmult + xmult);
							l.setAttribute("y1", wall.points[0].y * ymult + ymult);
							l.setAttribute("x2", wall.points[1].x * xmult + xmult);
							l.setAttribute("y2", wall.points[1].y * ymult + ymult);
							l.setAttribute("stroke", "#ff0008");
							l.setAttribute("stroke-width", "1");
							mySvg.appendChild(l);
						}
					}

//					// This code is useful for debugging the face-finding
//					// algorithm.  It puts a red dot in the middle of every
//					// face.
//					for (var x=0 ; x< all_cells.length ; x++) {
//						var cell = all_cells[x];
//						var center = cell.center();
//						var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
//						c.setAttribute("cx", center.x * xmult + xmult/2);
//						c.setAttribute("cy", center.y * ymult + ymult/2);
//						c.setAttribute("r", 2);
//						c.setAttribute("stroke", "#ff0008");
//						c.setAttribute("stroke-width", "1");
//						mySvg.appendChild(c);
//					}
				//]]>
			</script>

		  <p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a></p>

		</div>
	</body>

</html>
