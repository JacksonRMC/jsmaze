<?xml-stylesheet href="#maze-style" type="text/css"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

	<head>
		<title>Maze</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<style type="text/css" id="maze-style">
			html { width: 100%; height: 100%; }
			body, div, table, tr, th, td { margin: 0; padding: 0; border: 0; }
			body { width: 100%; height: 100%; background: #ddd; }
			div#wrap { width: 90%; height: 90%; margin: auto auto; }
			div#svg-container { width: 100%; height: 90%; background: #fff; }
		</style>
		<script type="text/javascript">
			// <![CDATA[

			// Get query parameters from the url.  This returns an object like this:
			//	?param            => args['param']=true
			// ?param=value      => args['param']=value
			// ?param[]=value    => args['param']=[value,...]
			function get_args() {
				var args = new Object();

				var query_string=location.search.slice(1);
				if (!query_string) return args;
				var query_pairs = query_string.split('&');

				var pname, pvalue;

				for (var i=0 ; i<query_pairs.length ; i++) {
					var equal_position=query_pairs[i].indexOf('=');
					if (equal_position<0) {
						args[my_uri_decoder(query_pairs[i])]=true;
					} else {
						pname=my_uri_decoder(query_pairs[i].slice(0,equal_position));
						pvalue=my_uri_decoder(query_pairs[i].slice(equal_position+1));
						// If a name is followed by [], then we'll create an array of
						// values.  This is good for a multiple-select box
						if (pname.indexOf('[]')==pname.length-2) {
							pname=pname.slice(0,-2);
							if (!args[pname]) args[pname]=new Array();
							args[pname].push(pvalue);
						} else {
							args[pname]=pvalue;
						}
					}
				}

				return args;
			}

			function my_uri_decoder(v) {
				return decodeURIComponent(v.replace(/\+/g,'%20'));
			}

			// Easily add functions to run at load time
			function add_body_onload(func) {
				var old_body_onload=window.onload;
				window.onload=function() {
					if (old_body_onload) { old_body_onload(); }
					func();
				}
			}

			// Gives us a random permutation.  This is Durstenfeld's
			// version of Knuth's shuffle, with in-place swapping.
			function random_perm(len) {
				var orig=Array(len);
				for (var x=0; x<len; x++) {
					orig[x]=x;
				}
				for (var x=len-1; x>0; x--) {
					var offset=Math.floor(Math.random()*(x+1));
					if (offset != x) {
						var tmp = orig[offset];
						orig[offset] = orig[x];
						orig[x] = tmp;
					}
				}
				return orig;
			}

			// The maze is set on a set of points, some of which connect to
			// form walls.  A closed set of walls connects to create a
			// cell.  We use object references between cells and walls
			// to quickly be able to traverse the maze.  So, a wall has a
			// list of both cells to which it connects and a cell has a
			// list of all of its walls.
			//
			// Points have an x,y coordinate that exists to specify their
			// position relative to other points.  They also have a set of
			// walls that use them as an end point.

			function Point(x, y) {
				this.x=x;
				this.y=y;
				this.walls=[];
			}

			Point.prototype.angle_to = function(other_point) {
				return Math.atan2(other_point.y-this.y,other_point.x-this.x)
			}

			Point.prototype.next_cw_wall = function(this_wall) {
				var wall_at = null;
				for (var j=0 ; j<this.walls.length ; j++) {
					if (this.walls[j] == this_wall) {
						wall_at = j;
						break;
					}
				}
				if (wall_at !== null) {
					if (wall_at > 0) {
						return this.walls[wall_at-1];
					} else {
						return this.walls[this.walls.length-1];
					}
				} else {
					return null;
				}
			}

			// Walls have a few pieces of information: two end points, the
			// state (open (0) or closed (1)), and the two cells that it
			// connects.

			function Wall(p1,p2) {
				this.points=[p1,p2];
				this.state=1;
				this.cells=[];
				p1.walls.push(this);
				p2.walls.push(this);
				// These are used for face finding - "down" is "point 0 to
				// point 1", "up" is "point 1 to point 0".
				this.traversed_down=false;
				this.traversed_up=false;
			}

			Wall.prototype.is_open = function() {
				return (this.state==0);
			}

			Wall.prototype.open = function() {
				if (this.state==0) {
					return null;
				} else {
					this.state=0;
					return true;
				}
			}

			Wall.prototype.center = function() {
				return(new Point((this.points[0].x+this.points[1].x)/2,(this.points[0].y+this.points[1].y)/2));
			}

			// Given a point, returns the "other end" point on the wall.
			Wall.prototype.other_end = function(point) {
				if (this.points[0] == point) {
					return(this.points[1]);
				} else if (this.points[1] == point) {
					return(this.points[0]);
				} else {
					return null;
				}
			}

			Wall.prototype.traverse = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					this.traversed_down = true;
					return point1;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					this.traversed_up = true;
					return point1;
				} else {
					return null;
				}
			}

			Wall.prototype.traversed = function(point0, point1) {
				if (point0 == this.points[0] && point1 == this.points[1]) {
					return this.traversed_down;
				} else if (point0 == this.points[1] && point1 == this.points[0]) {
					return this.traversed_up;
				} else {
					return null;
				}
			}

			Wall.prototype.toString = function() {
				return "" + this.points[0].x + ',' + this.points[0].y + ':' + this.points[1].x + ',' + this.points[1].y;
			}

			// Each wall has one or two cells (it's possible that
			// an edge wall may have only one cell).  This will
			// return "undefined" if there is no neighbor, otherwise it
			// will return the neighbor given a reference to one cell.
			Wall.prototype.neighbor = function(cell) {
				if (this.cells[0] == cell) {
					return this.cells[1];
				} else {
					return this.cells[0];
				}
			}

			// Cells have a set of walls along with a few other pieces of
			// information that are used while generating a maze.
			// Generally, a permutation of wall directions and a pointer to
			// the "current" item in the permutation list.

			function Cell(walls) {
				this.walls = walls;
				for (var i=0 ; i<this.walls.length ; i++) {
					this.walls[i].cells.push(this);
				}
				this.perm=random_perm(this.walls.length);
				this.current_perm=0;
				this.entry_wall=undefined;
				this.depth=undefined;
				// Used in drunk walk algorithm
				this.serial=undefined;
			}

			// Returns true if the cell has an open wall
			Cell.prototype.visited = function() {
				for (var i=0 ; i<this.walls.length ; i++) {
					if (this.walls[i].is_open()) {
						return true;
					}
				}
				return false;
			}

			// Returns a point representing the exact center of the cell.
			Cell.prototype.center = function() {
				var x_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					x_avg += this.walls[i].points[0].x;
					x_avg += this.walls[i].points[1].x;
				}
				x_avg /= this.walls.length * 2;
				var y_avg = 0.0;
				for (var i=0 ; i<this.walls.length ; i++) {
					y_avg += this.walls[i].points[0].y;
					y_avg += this.walls[i].points[1].y;
				}
				y_avg /= this.walls.length * 2;
				return(new Point(x_avg,y_avg));
			}

			// Return a list of all vertices of a cell, in order
			Cell.prototype.vertices = function() {
				var points = [];
				// I need to pick only a single point from each wall, and it
				// will be the point that isn't in the next wall.
				for (var i=0 ; i<this.walls.length ; i++) {
					var this_wall = this.walls[i];
					var next_wall = this.walls[i+1];
					if (!next_wall) { next_wall = this.walls[0]; }
					if (this_wall.points[0] != next_wall.points[0] && this_wall.points[0] != next_wall.points[1]) {
						points.push(this_wall.points[0]);
					} else {
						points.push(this_wall.points[1]);
					}
				}
				return points;
			}

			// A maze is a collection of cells with a path through them.
			// It is two graphs that are interconnected - one which is a
			// set of all walls (close and open) and the other a path
			// through the open walls.  This data structure holds
			// everything of interest about the maze.
			function Maze(xsize,ysize,base_style,maze_style) {
				// General data and accessors
				this.xsize = xsize;
				this.ysize = ysize;
				this.points = [];
				this.walls = [];
				this.cells = [];
				this.start_wall=null;
				this.end_wall=null;
				this.max_depth=null;
				this.end_depth=null;
				this.base_style=base_style;
				this.maze_style=maze_style;

				// Now, we'll initialize the maze.  First, set up the cells
				// according to the "base style".
				this.base_style(this.xsize, this.ysize, this.points, this.walls);
				this.sort_walls_for_points(this.points);
				// We now have a complete set of points and walls, we need to
				// walk that data structure and determine a set of cells.
				// In graph parlance, points == vertices, walls == edges, and
				// cells == faces.
				// There's a better more efficient way to do this - figure it
				// out later.
				// TODO: figure out a more efficient way to do this
				for (var j=0 ; j<this.points.length ; j++) {
					this.find_faces(this.points[j], this.cells);
				}
				// At this point, we're ready to actually make a maze.  Get
				// the start and end cells, then generate the maze.
				this.start_wall = this.find_start_wall(this.points);
				this.end_wall = this.find_end_wall(this.points);
				this.maze_style();
				// Purely for aesthetics, open the corners
				this.open_corners();
				// And set the max depth and end depth, which are useful for
				// rendering.
				this.find_max_depth();
				this.end_depth = this.end_cell().depth;
			}

			Maze.base_styles = {};
			Maze.maze_styles = {};

			// To create a maze, we need to move around until we're back to
			// the original point.  There's enough information stored in
			// each cell to perform this algorithm non-recursively in a
			// while loop.
			// If performed recursively, this algorithm is simple...
			Maze.maze_styles.recursive = function() {
				function recursive_maze(cell,entry_wall,depth) {
					cell.depth=depth;
					cell.entry_wall=entry_wall;
					// Now, go through the surrounding cells and recurse
					for (var k=0 ; k<cell.perm.length ; k++) {
						var wall_num = cell.perm[k];
						var neighbor = cell.walls[wall_num].neighbor(cell);
						if (neighbor && !neighbor.visited()) {
							cell.walls[wall_num].open();
							arguments.callee(neighbor,cell.walls[wall_num],depth+1);
						}
					}
				}

				recursive_maze(this.start_cell(),null,0);
			}

			// Create a maze using the drunk walk algorithm.  In this
			// algorithm, we create random segments that grow like the
			// recursive algorithm above until they connect to another
			// existing segment.  Each cell has a "serial" number that
			// specifies which segment it belongs to, so as a segment grows
			// it can see if it's touching "self" or "other".  It will
			// connect to "other" and quit growing.
			Maze.maze_styles.drunk_walk = function() {
				function drunk_walk(cell, entry_wall, serial, depth) {
					pieces_left--;
					cell.serial = serial;
					if (depth==0) return false;
					for (var k=0 ; k<cell.perm.length ; k++) {
						var wall_num = cell.perm[k];
						var wall = cell.walls[wall_num];
						if (wall != entry_wall && !wall.is_open()) {
							var neighbor = wall.neighbor(cell);
							if (neighbor) {
								if (!neighbor.serial) {
									wall.open();
									var ret=arguments.callee(neighbor,wall,serial,depth-1);
									if (!ret) return false;
								} else if (neighbor.serial != serial) {
									wall.open();
									return false;
								}
							}
						}
					}
					return true;
				}

				// Note that this is a scoped variable - the "drunk_walk"
				// function refers to it.
				var pieces_left = this.cells.length;

				// Note that this is declared here but the drunk_walk
				// function has "serial" as an argument, also.
				var serial = 1;

				// Grow an initial segment starting at a random location.
				// The length of the segment is up to 1/10th of the
				// available cells + 5.
				drunk_walk(this.cells[Math.floor(Math.random()*pieces_left)], null, serial++, Math.floor(Math.random()*pieces_left/10)+5);

				// Now, keep growing segments until we run out of pieces
				while (pieces_left>0) {
					var next_start=Math.floor(Math.random()*pieces_left)+1;
					var empty_found=0, i;
					for (i=0 ; i<this.cells.length ; i++) {
						if (!this.cells[i].serial) {
							empty_found++;
							if (empty_found >= next_start) {
								drunk_walk(this.cells[i], null, serial++, 99999999);
								break;
							}
						}
					}
				}

				this.find_depth(this.start_cell(), null, 0);
			}

			// Recursively finds the depths of all cells given a starting
			// point.  Make sure to do this before opening the start and
			// end.  This will also point all "entry walls" to the
			// beginning.
			Maze.prototype.find_depth = function(cell,entry_wall,depth) {
				cell.depth = depth;
				cell.entry_wall = entry_wall;
				for (var k=0 ; k<cell.walls.length; k++) {
					if (cell.walls[k] != entry_wall && cell.walls[k].is_open()) {
						arguments.callee(cell.walls[k].neighbor(cell),cell.walls[k],depth+1);
					}
				}
			}

			Maze.prototype.find_max_depth = function() {
				this.max_depth=0;
				for (var i=0 ; i<this.cells.length ; i++) {
					if (this.cells[i].depth > this.max_depth) { this.max_depth = this.cells[i].depth; }
				}
				return this.max_depth;
			}

			Maze.prototype.start_cell = function() {
				return this.start_wall.cells[0];
			}

			Maze.prototype.end_cell = function() {
				return this.end_wall.cells[0];
			}

			// This will create a simple square maze
			Maze.base_styles.square = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				for (var x=0 ; x<= xsize ; x++) {
					points_tracker[x] = Array(ysize+1);
					for (var y=0 ; y<= ysize ; y++) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build vertical walls
						if (y>0) {
							all_walls.push(new Wall(points_tracker[x][y-1], points_tracker[x][y]));
						}
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-1][y],points_tracker[x][y]));
						}
					}
				}
			}

			// Triangle maze - on odd rows the points are in odd columns,
			// in even rows the points are in even columns.
			Maze.base_styles.triangle = function(xsize,ysize,all_points,all_walls) {
				// points_tracker[x][y] = point - this exists only as a tool to
				// keep track of points for wall building.
				var points_tracker = Array(xsize+1);

				// First, make the points - even lines/cols
				for (var x = 0 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 0 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>0) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Next, make the points - odd lines/cols
				for (var x = 1 ; x < xsize+1 ; x += 2) {
					points_tracker[x] = Array(ysize+1);
					for (var y = 1 ; y < ysize+1 ; y += 2) {
						points_tracker[x][y] = new Point(x,y);
						all_points.push(points_tracker[x][y]);
						// Build horizontal walls
						if (x>1) {
							all_walls.push(new Wall(points_tracker[x-2][y],points_tracker[x][y]));
						}
					}
				}

				// Now, make walls from even cols to odd cols
				for (var x = 0 ; x < xsize ; x += 2) {
					for (var y=0 ; y < ysize ; y += 2) {
						if (points_tracker[x+1]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x][y+2]));
							}
						}
						if (points_tracker[x+2]) {
							if (points_tracker[x+1][y+1]) {
								all_walls.push(new Wall(points_tracker[x+2][y],points_tracker[x+1][y+1]));
							}
							if (points_tracker[x+2][y+2]) {
								all_walls.push(new Wall(points_tracker[x+1][y+1],points_tracker[x+2][y+2]));
							}
						}
					}
				}
			}

			// To ease the face-finding algorithm, we can sort the walls at
			// each point in order of angle.
			Maze.prototype.sort_walls_for_points = function(points) {
				for (var i = 0 ; i < points.length ; i++) {
					var point = points[i];
					// array of arrays: [wall, angle]
					var walls = [];
					for (var j = 0 ; j < point.walls.length ; j++) {
						var wall = point.walls[j];
						walls.push([wall,point.angle_to(wall.other_end(point))]);
					}
					function wall_sorter(a,b) { return(a[1]-b[1]); }
					walls.sort(wall_sorter);
					point.walls = [];
					for (var j = 0 ; j < walls.length ; j++) {
						point.walls.push(walls[j][0]);
					}
				}
			}

			// Finds all faces attached to a point that aren't yet "found"
			// and adds them to an array.
			Maze.prototype.find_faces = function(point, all_cells) {
				for (var i=0 ; i<point.walls.length ; i++) {
					var wall = point.walls[i];
					if (!wall.traversed(point,wall.other_end(point))) {
						var safety_counter = 0;
						var this_point=point;
						var walls = [];
						do {
							walls.push(wall);
							this_point = wall.traverse(this_point,wall.other_end(this_point));
							wall = this_point.next_cw_wall(wall)
							safety_counter++;
						} while (this_point != point && safety_counter < 20);
						if (safety_counter < 20) {
							all_cells.push(new Cell(walls));
						}
					}
				}
			}

			// Find the upper left starting wall
			Maze.prototype.find_start_wall = function(points) {
				for (var j=0 ; j<points.length ; j++) {
					var point = points[j];
					if (point.x==0 && point.y==0) {
						var start_cell = point.walls[0].cells[0];
						for (var j=0 ; j<start_cell.walls.length ; j++) {
							var wall = start_cell.walls[j];
							if (wall.cells.length==1 && !wall.is_open()) {
								return wall;
							}
						}
					}
				}
			}

			// Find the lower right ending wall
			Maze.prototype.find_end_wall = function(points) {
				for (var j=0 ; j<points.length ; j++) {
					var point = points[j];
					if (point.x==xsize && point.y==ysize) {
						var end_cell = point.walls[0].cells[0];
						for (var j=end_cell.walls.length-1 ; j>=0 ; j--) {
							var wall = end_cell.walls[j];
							if (wall.cells.length==1 && !wall.is_open()) {
								return wall;
							}
						}
					}
				}
			}

			// Opens the corners - knocks down walls to create a start and
			// end for the maze.
			Maze.prototype.open_corners = function() {
				// open opposite corners
				this.start_wall.open();
				this.end_wall.open();
			}

			//////////////////////////////////////////////////////////////
			//                                                          //
			//       Everything from here down pertains to display      //
			//                                                          //
			//////////////////////////////////////////////////////////////

			// Creates an svg element inside a container div
			function create_svg_element(div_id) {
				var container_div = document.getElementById(div_id);
				var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				svg.setAttribute("version", "1.2");
				svg.setAttribute("baseProfile", "tiny");
				svg.setAttribute("width", "100%");
				svg.setAttribute("height", "100%");
				container_div.appendChild(svg);
				return svg;
			}

			// Get the svg's width.  The issue here is that on Firefox the
			// svg's offsetWidth is undefined, so I need to instead get the
			// parent's offsetWidth.
			function svg_width(svg) {
				return svg.offsetWidth || svg.parentNode.offsetWidth;
			}

			// Get the height of the svg.
			function svg_height(svg) {
				return svg.offsetHeight || svg.parentNode.offsetHeight;
			}

			// Given the number of cells and svg, compute a width for
			// a single cell.
			function xmult_for(xsize, svg) {
				return svg_width(svg) / (xsize + 2);
			}

			// Given the number of cells and svg, compute a height for
			// a single cell.
			function ymult_for(ysize, svg) {
				return svg_height(svg) / (ysize + 2);
			}

			// Draw the background for the maze
			function draw_gradient_bg(end_depth, max_depth, svg) {
				var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
				defs.setAttribute('id', 'svgdefs');
				svg.appendChild(defs);

				var lg = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
				lg.setAttribute('id', 'svgbg');
				lg.setAttribute('x1', '0%');
				lg.setAttribute('x2', '100%');
				lg.setAttribute('y1', '0%');
				lg.setAttribute('y2', '100%');
				defs.appendChild(lg);

				var stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
				stop1.setAttribute('id', 'stop1');
				stop1.setAttribute('offset', '0%');
				stop1.setAttribute('stop-color', 'rgb(0,0,255)');
				lg.appendChild(stop1);

				var stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
				stop2.setAttribute('id', 'stop2');
				stop2.setAttribute('offset', '100%');
				stop2.setAttribute('stop-color', 'rgb(0,0,' + (255-Math.floor((end_depth/max_depth)*255)) + ')');
				lg.appendChild(stop2);

				var r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
				r.setAttribute("x", 0);
				r.setAttribute("y", 0);
				r.setAttribute("width", svg_width(svg));
				r.setAttribute("height", svg_height(svg));
				r.setAttribute("fill", 'url(#svgbg)');
				r.setAttribute("stroke", 'rgb(0,0,255)');
				r.setAttribute("stroke-width", "1");
				svg.appendChild(r);
			}

			// Draws the cells shaded according to depth, with
			// light blue being "shallow" and black being "deep"
			function draw_cell_depths(cells, xsize, ysize, max_depth, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x < cells.length ; x++) {
					var cell = cells[x];
					var points = cell.vertices();
					var points_list = [];
					for (var i=0 ; i < points.length ; i++) {
						points_list.push("" + Math.floor(points[i].x * xmult + xmult) + "," + Math.floor(points[i].y * ymult + ymult));
					}
					var p = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
					p.setAttribute("points", points_list.join(" "));
					p.setAttribute("fill", 'rgb(0,0,' + (255-Math.floor((cell.depth/max_depth)*255)) + ')');
					p.setAttribute("stroke", 'rgb(0,0,' + (255-Math.floor((cell.depth/max_depth)*255)) + ')');
					p.setAttribute("stroke-width", "1");
					svg.appendChild(p);
				}
			}

			// Draws a set of walls on an svg
			function draw_walls(walls, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x < walls.length ; x++) {
					var wall = walls[x];
					if (!wall.is_open()) {
						var l = document.createElementNS("http://www.w3.org/2000/svg", "line");
						l.setAttribute("x1", wall.points[0].x * xmult + xmult);
						l.setAttribute("y1", wall.points[0].y * ymult + ymult);
						l.setAttribute("x2", wall.points[1].x * xmult + xmult);
						l.setAttribute("y2", wall.points[1].y * ymult + ymult);
						l.setAttribute("stroke", "#ff0008");
						l.setAttribute("stroke-width", "1");
						svg.appendChild(l);
					}
				}
			}

			// This code is useful for debugging the face-finding
			// algorithm.  It puts a red dot in the middle of every
			// face.
			function show_cell_centers(cells, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);
				for (var x=0 ; x< cells.length ; x++) {
					var cell = cells[x];
					var center = cell.center();
					var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
					c.setAttribute("cx", center.x * xmult + xmult/2);
					c.setAttribute("cy", center.y * ymult + ymult/2);
					c.setAttribute("r", 2);
					c.setAttribute("stroke", "#ff0008");
					c.setAttribute("stroke-width", "1");
					svg.appendChild(c);
				}
			}

			// Draw the solution to the maze, starting at the end wall and
			// tracing back to the starting wall.
			function show_maze_solution(maze, xsize, ysize, svg) {
				var xmult = xmult_for(xsize, svg);
				var ymult = ymult_for(ysize, svg);

				var points = [];

				// First, draw from the center of the end wall to the center
				// of the end cell.
				var end_wall_center = maze.end_wall.center();
				var end_cell = maze.end_cell();

				points.push(end_wall_center);

				var start_wall_center = maze.start_wall.center();
				var start_cell = maze.start_cell();

				var current_cell = end_cell;

				do {
					points.push(current_cell.center());
					current_cell = current_cell.entry_wall.neighbor(current_cell);
				} while (current_cell != start_cell)

				points.push(start_cell.center());
				points.push(start_wall_center);

				var points_xy = [];
				for (var i=0 ; i<points.length ; i++) {
					points_xy.push('' + (points[i].x * xmult + xmult) + ',' + (points[i].y * ymult + ymult));
				}

				var points_str = points_xy.join(' ');

				var pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
				pl.setAttribute("points", points_str);
				pl.setAttribute("fill", "none");
				pl.setAttribute("stroke", "#ffff00");
				pl.setAttribute("stroke-width", "1");
				pl.setAttribute("id", "solution");
				svg.appendChild(pl);
			}

			// Leaving these as globals
			var args=get_args();

			var xsize=parseInt(args['xsize']);
			var ysize=parseInt(args['ysize']);
			var maze_style = args['style'];
			var maze_algorithm = args['algo'];
			var show_solution = args['solution'];
			if (!xsize) xsize=10;
			if (!ysize) ysize=10;
			if (!maze_style) maze_style='square';
			if (!maze_algorithm) maze_algorithm='recursive';

			// Actually makes the maze
			function make_a_maze() {
				var maze = new Maze(xsize, ysize, (maze_style=='triangle' ?  Maze.base_styles.triangle : Maze.base_styles.square), (maze_algorithm=='drunk_walk' ? Maze.maze_styles.drunk_walk : Maze.maze_styles.recursive));

				// With the maze created, we'll display it
				var svg = create_svg_element("svg-container");
				draw_gradient_bg(maze.end_depth, maze.max_depth, svg);
				draw_cell_depths(maze.cells, maze.xsize, maze.ysize, maze.max_depth, svg);
				draw_walls(maze.walls, maze.xsize, maze.ysize, svg);
				if (show_solution) show_maze_solution(maze, maze.xsize, maze.ysize, svg);
			}

			add_body_onload(make_a_maze);

			//]]>
		</script>
	</head>

	<body>

		<div id="wrap">

			<h1>JavaScript Maze</h1>

			<div id="svg-container"></div>

			<script type="text/javascript">
				// <![CDATA[
				//]]>
			</script>

		</div>
	</body>

</html>
